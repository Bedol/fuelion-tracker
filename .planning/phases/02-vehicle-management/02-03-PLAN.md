---
phase: 02-vehicle-management
plan: 03
type: execute
wave: 2
depends_on: ['02-01']
files_modified:
  - components/vehicles/VehicleForm.tsx
  - pages/vehicles/new.tsx
  - pages/vehicles/[id]/edit.tsx
  - types/vehicle_types.ts
autonomous: true

must_haves:
  truths:
    - 'User can create vehicle with brand, model, year, fuel type (required fields)'
    - 'User can optionally add registration number'
    - 'User can optionally add technical data (engine capacity, power)'
    - 'Form has smart layout with collapsible technical section'
    - 'Form validates required fields'
  artifacts:
    - path: 'components/vehicles/VehicleForm.tsx'
      provides: 'Unified vehicle form for create/edit'
      min_lines: 150
    - path: 'pages/vehicles/new.tsx'
      provides: 'Create vehicle page using VehicleForm'
      min_lines: 60
    - path: 'pages/vehicles/[id]/edit.tsx'
      provides: 'Edit vehicle page using VehicleForm'
      min_lines: 80
  key_links:
    - from: 'components/vehicles/VehicleForm.tsx'
      to: '/api/vehicles'
      via: 'mutation passed as prop'
      pattern: 'mutation.mutate'
    - from: 'pages/vehicles/new.tsx'
      to: 'components/vehicles/VehicleForm.tsx'
      via: 'import and render'
      pattern: 'import.*VehicleForm'
---

<objective>
Create a unified, well-designed vehicle form that handles both create and edit operations with all required and optional fields per CONTEXT.md decisions.

Purpose: Current forms are inconsistent (new.tsx has old structure, VehicleForm.tsx is minimal), field names don't match schema, and technical data section is missing. Need single form component matching simplified schema and user requirements.

Output: Enhanced VehicleForm component used by both create and edit pages with proper field mapping, validation, and collapsible technical data section.
</objective>

<execution_context>
@/home/bweber/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/bweber/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-vehicle-management/02-CONTEXT.md
@.planning/phases/02-vehicle-management/02-01-SUMMARY.md
@components/vehicles/VehicleForm.tsx
@pages/vehicles/new.tsx
@pages/vehicles/[id]/edit.tsx
@types/vehicle_types.ts
@prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Rebuild VehicleForm component with complete fields</name>
  <files>components/vehicles/VehicleForm.tsx</files>
  <action>
Completely rewrite components/vehicles/VehicleForm.tsx to match the simplified schema and CONTEXT.md decisions:

**Form structure (single page, not wizard):**

**Section 1: Basic Information (always visible)**

- **Brand** (text input, required) - maps to `brand_name`
- **Model** (text input, required) - maps to `model_name`
- **Production Year** (number input, required, range: 1900 to current year + 1) - maps to `production_year`
- **Fuel Type** (select dropdown, required) - maps to `fuel_type` string
  - Options: "gasoline", "diesel", "lpg", "electric", "hybrid"
- **Registration Number** (text input, optional, placeholder "ABC 1234") - maps to `registration_number`

**Section 2: Technical Data (collapsible, initially collapsed)**

- "Add technical data" link/button to expand section
- When expanded, show:
  - **Engine Capacity** (number input, optional, unit: cc) - maps to `engine_capacity`
  - **Engine Power** (number input, optional) - maps to `engine_power`
  - **Power Unit** (select, optional, options: "HP", "kW") - maps to `power_unit`
  - **Transmission** (select, optional, options: "manual", "automatic") - maps to `transmission`

**Props interface:**

```typescript
type VehicleFormProps = {
	initialValues: {
		brand_name: string;
		model_name: string;
		production_year: number;
		fuel_type: string;
		registration_number?: string;
		engine_capacity?: number;
		engine_power?: number;
		power_unit?: string;
		transmission?: string;
	};
	mutation: any; // TanStack Query mutation
	mode: 'create' | 'edit';
};
```

**Implementation details:**

- Use Formik for form state (existing pattern)
- Use Chakra UI components: FormControl, FormLabel, Input, Select, Button, Collapse/Accordion for technical section
- Add basic validation: required fields must not be empty
- Show loading state on submit button using `mutation.isPending` (TanStack Query v5 syntax, not isLoading)
- On success, navigate back to `/vehicles` using Next.js router
- Buttons: "Submit" (primary), "Cancel" (secondary, navigates to `/vehicles`)

**Do NOT:**

- Add autocomplete for brand/model (defer to future)
- Add Formik validation schema with Yup (keep it simple for v1)
- Add complex year picker (simple number input is fine)
  </action>
  <verify>
  Check that VehicleForm.tsx exports component with proper TypeScript types. Verify all fields map to schema field names (brand_name, model_name, fuel_type, etc.). Confirm Collapse/Accordion component works for technical data section.
  </verify>
  <done>
  VehicleForm component exists with all basic and technical fields, collapsible technical section, proper field mapping to schema, and Formik + Chakra UI implementation.
  </done>
  </task>

<task type="auto">
  <name>Update create and edit pages to use enhanced form</name>
  <files>pages/vehicles/new.tsx, pages/vehicles/[id]/edit.tsx</files>
  <action>
**Update pages/vehicles/new.tsx:**
1. Remove old form implementation (lines 27-206)
2. Import enhanced VehicleForm component
3. Set up TanStack Query mutation for POST /api/vehicles
4. Use new Chakra UI toaster.create() for success/error feedback (Phase 1 pattern)
5. Pass initialValues with sensible defaults:
   - brand_name: "", model_name: ""
   - production_year: new Date().getFullYear()
   - fuel_type: "gasoline"
   - registration_number: ""
   - Technical fields: undefined (optional)
6. Set mode="create"
7. Mutation should POST to `/api/vehicles` with user_id from session

**Update pages/vehicles/[id]/edit.tsx:**

1. Fix field name mapping (currently uses "brand", "model", "production_year" but schema uses "brand_name", "model_name", "production_year")
2. Update initialValues to include all fields from fetched vehicle data:
   - Basic: brand_name, model_name, production_year, fuel_type, registration_number
   - Technical: engine_capacity, engine_power, power_unit, transmission
3. Set mode="edit"
4. Update mutation to PUT /api/vehicles/[id]
5. Use toaster.create() for success feedback (not old useToast pattern)

**Both pages:**

- Wrap in proper layout (authenticated users only)
- Add page heading with Chakra Heading component
- Handle loading and error states from data fetch (edit page)
- Ensure session is required (useSession hook)

**Important:** Match the toaster pattern from Phase 1 (use `toaster.create({ type: 'success', title: '...' })`, not the old useToast API).
</action>
<verify>
Run `npm run dev` and visit `/vehicles/new`. Check that form displays with all fields. Verify technical data section is collapsed by default and expands on click. Visit edit page for existing vehicle and confirm fields are pre-populated. Test form submission and check browser network tab for correct API calls.
</verify>
<done>
Create and edit pages use enhanced VehicleForm component with proper field mapping, session handling, and toaster feedback.
</done>
</task>

<task type="auto">
  <name>Update vehicle types to match schema</name>
  <files>types/vehicle_types.ts</files>
  <action>
Update types/vehicle_types.ts to align with simplified schema:

1. **Update VehicleData type** to match Prisma schema fields:

```typescript
export type VehicleData = {
	id: number;
	user_id: number;
	brand_name: string;
	model_name: string;
	production_year: number;
	fuel_type: string; // "gasoline" | "diesel" | "lpg" | "electric" | "hybrid"
	registration_number?: string;
	engine_capacity?: number;
	engine_power?: number;
	power_unit?: string; // "HP" | "kW"
	transmission?: string; // "manual" | "automatic"
	vehicle_type?: string; // "car" | "truck" | "motorcycle"
	mileage: number;
	mileage_unit: string;
	currency: string;
	created_at: Date;
	updated_at: Date;
};
```

2. **Update fuelTypes array** to match schema values:

```typescript
export const fuelTypes: SelectOptionType[] = [
	{ id: 1, name: 'Gasoline', value: 'gasoline' },
	{ id: 2, name: 'Diesel', value: 'diesel' },
	{ id: 3, name: 'LPG', value: 'lpg' },
	{ id: 4, name: 'Electric', value: 'electric' },
	{ id: 5, name: 'Hybrid', value: 'hybrid' },
];
```

3. **Add transmission options:**

```typescript
export const transmissionTypes: SelectOptionType[] = [
	{ id: 1, name: 'Manual', value: 'manual' },
	{ id: 2, name: 'Automatic', value: 'automatic' },
];
```

4. **Add power unit options:**

```typescript
export const powerUnits: SelectOptionType[] = [
	{ id: 1, name: 'Horsepower (HP)', value: 'HP' },
	{ id: 2, name: 'Kilowatts (kW)', value: 'kW' },
];
```

5. **Keep existing enums** but note they're not actively used (keep for potential future use)

**Do NOT:**

- Remove existing types/enums (might be used elsewhere)
- Change currencies array (still valid)
  </action>
  <verify>
  Check that types/vehicle_types.ts exports VehicleData, fuelTypes, transmissionTypes, powerUnits. Verify values match schema strings (lowercase fuel types, etc.).
  </verify>
  <done>
  Type definitions align with simplified Prisma schema and provide proper types for forms.
  </done>
  </task>

</tasks>

<verification>
- [ ] VehicleForm component has all basic fields (brand, model, year, fuel type, registration)
- [ ] VehicleForm has collapsible technical data section
- [ ] Create page (`/vehicles/new`) uses VehicleForm with empty initial values
- [ ] Edit page uses VehicleForm with fetched vehicle data
- [ ] Field names match schema (brand_name, model_name, fuel_type, etc.)
- [ ] Form submission triggers correct API calls (POST for create, PUT for edit)
- [ ] Success feedback shows toast notification
- [ ] Forms redirect to `/vehicles` after success
- [ ] TypeScript compilation succeeds
</verification>

<success_criteria>
Unified vehicle form component handles both create and edit with all required and optional fields. Forms match schema field names and CONTEXT.md design decisions. Technical data section is collapsible. Success feedback uses toaster.
</success_criteria>

<output>
After completion, create `.planning/phases/02-vehicle-management/02-03-SUMMARY.md`
</output>
