---
phase: 01-auth-app-shell
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - components/ui/SkeletonLoader.tsx
  - components/ui/ErrorAlert.tsx
  - pages/index.tsx
autonomous: true

must_haves:
  truths:
    - 'SkeletonLoader and ErrorAlert components exist and build successfully'
    - 'SkeletonLoader demonstrates page variant in index.tsx loading state'
    - 'Loading and error components use i18n translations'
  artifacts:
    - path: 'components/ui/SkeletonLoader.tsx'
      provides: 'Skeleton loading placeholder component with type variants'
      exports: ['default']
      min_lines: 30
    - path: 'components/ui/ErrorAlert.tsx'
      provides: 'Error alert with collapsible details'
      exports: ['default']
      min_lines: 40
  key_links:
    - from: 'components/ui/SkeletonLoader.tsx'
      to: '@chakra-ui/react'
      via: 'Skeleton component import'
      pattern: 'import.*Skeleton.*@chakra-ui'
    - from: 'components/ui/ErrorAlert.tsx'
      to: 'contexts/LocaleContext'
      via: 'useLocale for translations'
      pattern: 'useLocale'
---

<objective>
Create enhanced loading and error components following UIUX-06 requirement (loading and error states clearly displayed).

Purpose: Establish consistent loading/error patterns for use throughout the application. Skeleton screens prevent layout shift and provide better UX than spinners alone. Enhanced error alerts with collapsible details help debugging while remaining user-friendly.

Output: Reusable SkeletonLoader component with type variants (page, list, card) and ErrorAlert component with i18n support and collapsible technical details.
</objective>

<execution_context>
@/home/bweber/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/bweber/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auth-app-shell/01-CONTEXT.md
@.planning/phases/01-auth-app-shell/01-RESEARCH.md
@components/Loading.tsx
@components/errors/FetchDataErrorAlert.tsx
</context>

<tasks>

<task type="auto">
  <name>Create SkeletonLoader component with type variants</name>
  <files>
    components/ui/SkeletonLoader.tsx
  </files>
  <action>
Create new SkeletonLoader component with configurable types for different loading contexts.

Component requirements:

- TypeScript with props: `type?: 'page' | 'list' | 'card'` (default 'page')
- Import Chakra UI: Stack, Skeleton, SkeletonText, Box
- Implement three variants:

  **page variant (default):**
  - Stack container with gap="6", maxW="1200px", mx="auto"
  - Large heading skeleton (height="40px", width="300px")
  - Content block skeleton (height="200px")
  - Text skeleton (SkeletonText with noOfLines={4})

  **list variant:**
  - Stack with gap="4"
  - Map 3 card placeholders, each with:
    - Box container (p="4", borderWidth="1px", borderRadius="md")
    - Title skeleton (height="20px", width="60%", mb="2")
    - SkeletonText with noOfLines={2}

  **card variant:**
  - Single Box container (p="4", borderWidth="1px", borderRadius="md")
  - Image placeholder skeleton (height="150px", mb="4")
  - SkeletonText with noOfLines={3}

Follow research code example "Skeleton Loader Component".

Export as default: `export default SkeletonLoader`

Keep existing Loading.tsx component (it's still useful for inline spinners). This new component is for page-level loading states.
</action>
<verify>
Check file exists: `ls components/ui/SkeletonLoader.tsx`
Check imports: `grep "import.*Skeleton.*@chakra-ui" components/ui/SkeletonLoader.tsx`
Check variants: `grep -E "(type === 'list'|type === 'card')" components/ui/SkeletonLoader.tsx`
Run build: `npm run build` to check for TypeScript errors
</verify>
<done>
SkeletonLoader.tsx exists with page, list, and card variants. Uses Chakra UI Skeleton components. Builds without TypeScript errors. Ready for use in protected pages during data fetching.
</done>
</task>

<task type="auto">
  <name>Create enhanced ErrorAlert component</name>
  <files>
    components/ui/ErrorAlert.tsx
  </files>
  <action>
Create new ErrorAlert component that replaces FetchDataErrorAlert with enhanced features.

Component requirements:

- TypeScript props: `error: Error | { message: string }`, `title?: string`
- Import Chakra UI: Alert from @chakra-ui/react, Box, Button, Collapsible
- Import useLocale: `import { useLocale } from '@/contexts/LocaleContext'`
- State for collapsible details: `const [showDetails, setShowDetails] = useState(false)`

Structure:

- Alert.Root with status="error"
- Alert.Indicator (error icon)
- Alert.Title: Use provided title or fallback to `t('errors.generic')`
- Alert.Description: Show error.message or `t('errors.tryAgain')`
- If error.stack exists:
  - Button (size="sm", variant="ghost") to toggle details
    - Text: showDetails ? t('errors.hideDetails') : t('errors.showDetails')
  - Collapsible.Root with open={showDetails}
  - Collapsible.Content with error.stack in <pre> tag
    - Style: fontSize="xs", p="2", bg="gray.100", borderRadius="md", overflow="auto"

Follow research code example "Enhanced Error Alert".

Note: Chakra UI 3.x uses Alert.Root, Alert.Indicator, Alert.Title, Alert.Description pattern (not AlertIcon/AlertTitle like v2).

Export as default: `export default ErrorAlert`

Keep existing FetchDataErrorAlert.tsx (backward compatibility), but new code should use ErrorAlert.
</action>
<verify>
Check file exists: `ls components/ui/ErrorAlert.tsx`
Check i18n integration: `grep "useLocale" components/ui/ErrorAlert.tsx`
Check Collapsible: `grep "Collapsible" components/ui/ErrorAlert.tsx`
Check Alert v3 API: `grep "Alert.Root" components/ui/ErrorAlert.tsx`
Run build: `npm run build` to check for TypeScript errors
</verify>
<done>
ErrorAlert.tsx exists with i18n support, collapsible error details, and Chakra UI v3 Alert API. Builds without errors. Provides better UX than existing FetchDataErrorAlert with optional technical details.
</done>
</task>

<task type="auto">
  <name>Integrate SkeletonLoader into index page loading state</name>
  <files>
    pages/index.tsx
  </files>
  <action>
Update the index page to use SkeletonLoader component during session loading instead of the generic Loading component.

Changes needed:

- Import SkeletonLoader: `import SkeletonLoader from '../components/ui/SkeletonLoader'`
- Replace loading state rendering:
  - Change `if (status === "loading") return <Loading />`
  - To: `if (status === "loading") return <SkeletonLoader type="page" />`

This demonstrates UIUX-06 requirement (loading states clearly displayed) with page-level skeleton instead of simple spinner.

Keep the rest of the page unchanged (session protection, welcome message, etc.).
</action>
<verify>
Check SkeletonLoader import: `grep "import SkeletonLoader" pages/index.tsx`
Check usage in loading state: `grep "SkeletonLoader.*type=\"page\"" pages/index.tsx`
Run dev server: `npm run dev` and visit http://localhost:3000 while signed out to see skeleton during session check
</verify>
<done>
Index page uses SkeletonLoader for loading state. UIUX-06 requirement is now demonstrated with actual usage. Loading state shows page skeleton instead of spinner.
</done>
</task>

</tasks>

<verification>
1. Run `npm run build` - should complete without errors
2. Check SkeletonLoader exists: `ls components/ui/SkeletonLoader.tsx`
3. Check ErrorAlert exists: `ls components/ui/ErrorAlert.tsx`
4. Check index.tsx uses SkeletonLoader: `grep "SkeletonLoader" pages/index.tsx`
5. Verify both components use proper TypeScript types
6. Verify ErrorAlert uses useLocale hook for i18n
7. Visit http://localhost:3000 while signed out - should briefly see skeleton loader
</verification>

<success_criteria>

1. SkeletonLoader component exists with page, list, and card variants
2. SkeletonLoader uses Chakra UI Skeleton and SkeletonText components
3. ErrorAlert component exists with collapsible error details
4. ErrorAlert uses i18n translations for user-facing messages
5. Both components build without TypeScript errors
6. SkeletonLoader is demonstrated in use on index.tsx loading state (UIUX-06)
7. Components are ready for use in later phases (Vehicles, Fuelings, Statistics)
   </success_criteria>

<output>
After completion, create `.planning/phases/01-auth-app-shell/01-03-SUMMARY.md`
</output>
