---
phase: 03-fueling-records
plan: 04
type: execute
wave: 4
depends_on:
  - 03-01
  - 03-02
  - 03-03
files_modified:
  - pages/api/fueling/index.ts
  - pages/api/fueling/last.ts
  - pages/api/fueling/[id].ts
  - pages/vehicles/[id]/fuelings/index.tsx
  - pages/vehicles/[id]/fuelings/new.tsx
  - pages/vehicles/[id]/fuelings/[fuelingId]/edit.tsx
autonomous: false

must_haves:
  truths:
    - 'API routes handle GET (paginated list), POST (create), PUT (update), DELETE (delete)'
    - 'Last fueling API returns most recent fueling for smart defaults'
    - 'Fueling list page displays fuelings with add button and empty state'
    - 'New fueling page has form with vehicle context'
    - 'Edit fueling page pre-fills form with existing data'
    - 'All pages use vehicle detail page layout pattern'
    - 'Navigation works: list → new → (save) → list, list → edit → (save) → list'
  artifacts:
    - path: 'pages/api/fueling/index.ts'
      provides: 'List and create API endpoints'
      exports: ['default handler']
      min_lines: 80
      routes:
        - 'GET /api/fueling?vehicleId=X&skip=Y&take=Z'
        - 'POST /api/fueling'
    - path: 'pages/api/fueling/last.ts'
      provides: 'Last fueling API for smart defaults'
      exports: ['default handler']
      min_lines: 40
      routes:
        - 'GET /api/fueling/last?vehicleId=X'
    - path: 'pages/api/fueling/[id].ts'
      provides: 'Single fueling CRUD operations'
      exports: ['default handler']
      min_lines: 100
      routes:
        - 'GET /api/fueling/[id]'
        - 'PUT /api/fueling/[id]'
        - 'DELETE /api/fueling/[id]'
    - path: 'pages/vehicles/[id]/fuelings/index.tsx'
      provides: 'Fueling list page'
      exports: ['default']
      min_lines: 80
    - path: 'pages/vehicles/[id]/fuelings/new.tsx'
      provides: 'Create fueling page'
      exports: ['default']
      min_lines: 60
    - path: 'pages/vehicles/[id]/fuelings/[fuelingId]/edit.tsx'
      provides: 'Edit fueling page'
      exports: ['default']
      min_lines: 80
  key_links:
    - from: 'pages/api/fueling/index.ts'
      to: 'prisma.fueling.findMany, prisma.fueling.create'
      via: 'Prisma client'
      pattern: 'prisma.fueling'
    - from: 'pages/vehicles/[id]/fuelings/index.tsx'
      to: 'FuelingList component'
      via: 'component import'
      pattern: 'import.*FuelingList'
    - from: 'pages/vehicles/[id]/fuelings/new.tsx'
      to: 'FuelingForm component'
      via: "component import with mode='create'"
      pattern: 'mode="create"'
---

<objective>
Create API routes and page components to complete the fueling records feature.

Purpose: This plan wires everything together - API endpoints for CRUD operations, and page components that compose the UI components from Plan 03 with the data layer from Plan 02. This completes the full user flow for fueling records.

Output: Three API route files and three page files that implement the complete fueling CRUD interface.
</objective>

<execution_context>
@/home/bweber/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/bweber/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-fueling-records/03-01-SUMMARY.md
@.planning/phases/03-fueling-records/03-02-SUMMARY.md
@.planning/phases/03-fueling-records/03-03-SUMMARY.md
@pages/vehicles/[id]/index.tsx

**Prisma Fueling model (relevant fields):**

```prisma
model Fueling {
  id                Int       @id @default(autoincrement())
  quantity          Float     @default(0.0)
  cost              Float     @default(0.0)
  cost_per_unit     Float     @default(0.0)
  date              DateTime? @db.Date
  mileage           Float     @default(0.0)
  fuel_type_id      Int
  full_tank         Boolean   @default(true)
  vehicle_id        Int
  vehicle           Vehicle   @relation(fields: [vehicle_id], references: [id], onDelete: Cascade)
}
```

**API patterns to follow:**

- Use switch statement for HTTP method handling (from AGENTS.md)
- Session check: `const session = await getServerSession(req, res, authOptions)`
- Return appropriate status codes: 200 (GET), 201 (POST), 404 (not found), 400 (bad request), 500 (error)
- Use Prisma client from `lib/prisma.ts`

**Page patterns to follow (from pages/vehicles/[id]/index.tsx):**

- Use `getServerSideProps` or client-side data fetching with useQuery
- Check authentication with `useSession` or server-side session
- Use Layout component from components/Layout.tsx
- Show loading states while fetching vehicle data
- Handle errors with error components

**Route structure:**

- /vehicles/[id]/fuelings/ - List page
- /vehicles/[id]/fuelings/new - Create page
- /vehicles/[id]/fuelings/[fuelingId]/edit - Edit page

**Navigation flow:**

1. User on vehicle detail → clicks "Fuelings" → list page
2. List page → "Add Fueling" button → new page
3. New page → Submit → POST /api/fueling → navigate back to list with toast
4. List page → Edit button on item → edit page
5. Edit page → Submit → PUT /api/fueling/[id] → navigate back to list with toast
6. List page → Delete button → modal → DELETE /api/fueling/[id] → stay on list with toast
   </context>

<tasks>

<task type="auto">
  <name>Task 1: Create API routes (index.ts, last.ts, [id].ts)</name>
  <files>pages/api/fueling/index.ts, pages/api/fueling/last.ts, pages/api/fueling/[id].ts</files>
  <action>
    Create the three API route files for fueling operations:

    **pages/api/fueling/index.ts** (List and Create):
    ```typescript
    // GET handler - paginated list
    const handleGet = async (req: NextApiRequest, res: NextApiResponse) => {
      const session = await getServerSession(req, res, authOptions);
      if (!session) return res.status(401).json({ error: 'Unauthorized' });

      const { vehicleId, skip = '0', take = '20' } = req.query;
      if (!vehicleId) return res.status(400).json({ error: 'vehicleId required' });

      const fuelings = await prisma.fueling.findMany({
        where: { vehicle_id: Number(vehicleId) },
        orderBy: { date: 'desc' }, // Newest first
        skip: Number(skip),
        take: Number(take),
      });

      res.json(fuelings);
    };

    // POST handler - create
    const handlePost = async (req: NextApiRequest, res: NextApiResponse) => {
      const session = await getServerSession(req, res, authOptions);
      if (!session) return res.status(401).json({ error: 'Unauthorized' });

      const data = req.body;
      // Validate required fields: cost, quantity, mileage, date, vehicle_id
      // Create with prisma.fueling.create({ data: {...} })
      // Return 201 with created fueling
    };

    // Main handler with switch
    export default async function handler(req: NextApiRequest, res: NextApiResponse) {
      switch (req.method) {
        case 'GET': return handleGet(req, res);
        case 'POST': return handlePost(req, res);
        default: res.setHeader('Allow', ['GET', 'POST']); return res.status(405).end();
      }
    }
    ```

    **pages/api/fueling/last.ts** (Last fueling for defaults):
    ```typescript
    // GET handler only
    const { vehicleId } = req.query;
    const lastFueling = await prisma.fueling.findFirst({
      where: { vehicle_id: Number(vehicleId) },
      orderBy: { date: 'desc' },
    });
    if (!lastFueling) return res.status(404).json({ error: 'No fuelings found' });
    res.json(lastFueling);
    ```

    **pages/api/fueling/[id].ts** (Get, Update, Delete single):
    ```typescript
    // GET - single fueling
    const fueling = await prisma.fueling.findUnique({ where: { id: Number(id) } });
    if (!fueling) return res.status(404).json({ error: 'Fueling not found' });

    // PUT - update
    const updated = await prisma.fueling.update({
      where: { id: Number(id) },
      data: { /* mapped fields */ }
    });

    // DELETE - delete
    await prisma.fueling.delete({ where: { id: Number(id) } });
    res.status(204).end();

    // Switch: GET, PUT, DELETE
    ```

    **Data mapping notes:**
    - API receives: cost (string), quantity (string), mileage (string), date (string 'yyyy-MM-dd')
    - Prisma stores: cost (Float), quantity (Float), mileage (Float), date (DateTime)
    - Convert: `parseFloat()` for numbers, `new Date(date)` for date
    - fuel_type: store as string (simplified from fuel_type_id)
    - cost_per_unit: calculated, store with 3 decimal precision

    **Import requirements:**
    - `import type { NextApiRequest, NextApiResponse } from 'next'`
    - `import { getServerSession } from 'next-auth/next'`
    - `import { authOptions } from '../auth/[...nextauth]'` (adjust path)
    - `import prisma from '../../../lib/prisma'` (adjust path)

  </action>
  <verify>ls -la pages/api/fueling/index.ts pages/api/fueling/last.ts pages/api/fueling/[id].ts</verify>
  <done>All three API route files exist with proper GET, POST, PUT, DELETE handlers, session checks, and Prisma operations</done>
</task>

<task type="auto">
  <name>Task 2: Create fueling list page</name>
  <files>pages/vehicles/[id]/fuelings/index.tsx</files>
  <action>
    Create the fueling list page at `pages/vehicles/[id]/fuelings/index.tsx`:

    **Page structure:**
    1. **Imports:**
       - Layout from components/Layout.tsx
       - FuelingList, FuelingDeleteModal from components/fueling
       - useFuelings hook from hooks/
       - useSession from next-auth/react
       - useRouter from next/router
       - Loading, ErrorAlert from components/ui/

    2. **Data fetching:**
       - Get vehicle ID from router.query.id
       - Fetch vehicle data (reuse existing pattern from vehicle detail page)
       - Pass vehicleId to FuelingList component

    3. **State:**
       - deleteModalOpen: boolean
       - selectedFueling: FuelingData | null (for delete modal)

    4. **Handlers:**
       - handleAddFueling: router.push(`/vehicles/${id}/fuelings/new`)
       - handleEdit: router.push(`/vehicles/${id}/fuelings/${fueling.id}/edit`)
       - handleDeleteClick: set selectedFueling, open modal
       - handleDeleteSuccess: close modal, refetch list (or rely on query invalidation)

    5. **Render:**
       - Page title: "{vehicle.brand_name} {vehicle.model_name} - Fuelings"
       - Add Fueling button (primary, at top)
       - FuelingList component with:
         - vehicleId
         - currency={vehicle.currency}
         - onEdit={handleEdit}
         - onDelete={handleDeleteClick}
       - FuelingDeleteModal with:
         - isOpen={deleteModalOpen}
         - fueling={selectedFueling}
         - currency={vehicle.currency}
         - onDeleteSuccess={handleDeleteSuccess}

    6. **Empty state handling:**
       - FuelingList component handles this internally

    7. **Loading/error states:**
       - Show Loading while fetching vehicle
       - Show ErrorAlert on error

    **Pattern to follow:**
    - Similar to pages/vehicles/[id]/index.tsx structure
    - Use useQuery for vehicle data fetching
    - Reuse existing patterns for auth checks

    **File size:** ~80 lines

  </action>
  <verify>wc -l pages/vehicles/[id]/fuelings/index.tsx</verify>
  <done>Fueling list page exists with vehicle context, FuelingList component, add button, and delete modal integration</done>
</task>

<task type="auto">
  <name>Task 3: Create new and edit fueling pages</name>
  <files>pages/vehicles/[id]/fuelings/new.tsx, pages/vehicles/[id]/fuelings/[fuelingId]/edit.tsx</files>
  <action>
    Create the create and edit fueling pages:

    **pages/vehicles/[id]/fuelings/new.tsx** (Create fueling):
    ```typescript
    // Get vehicle ID from router.query.id
    // Fetch vehicle data for context and smart defaults
    // Render:
    <Layout title="Add Fueling">
      <Heading size="lg" mb={4}>Add Fueling</Heading>
      <Text mb={4}>{vehicle.brand_name} {vehicle.model_name}</Text>
      <FuelingForm
        vehicle={vehicle}
        mode="create"
        onSubmitSuccess={() => router.push(`/vehicles/${id}/fuelings`)}
      />
    </Layout>
    ```

    **pages/vehicles/[id]/fuelings/[fuelingId]/edit.tsx** (Edit fueling):
    ```typescript
    // Get vehicleId and fuelingId from router.query
    // Fetch both vehicle and fueling data
    // Render:
    <Layout title="Edit Fueling">
      <Heading size="lg" mb={4}>Edit Fueling</Heading>
      <Text mb={4}>{vehicle.brand_name} {vehicle.model_name}</Text>
      <FuelingForm
        vehicle={vehicle}
        initialData={fueling}
        mode="edit"
        onSubmitSuccess={() => router.push(`/vehicles/${vehicleId}/fuelings`)}
      />
    </Layout>
    ```

    **Common patterns for both pages:**
    1. **Authentication check:**
       - Use `useSession` with `required: true`
       - Redirect to sign-in if not authenticated

    2. **Vehicle data fetching:**
       - Use `useQuery` with key `['vehicle', id]`
       - Fetch from `/api/vehicles/${id}`
       - Handle loading and error states

    3. **Fueling data fetching (edit page only):**
       - Use `useQuery` with key `['fueling', fuelingId]`
       - Fetch from `/api/fueling/${fuelingId}`
       - Handle 404 if fueling doesn't exist

    4. **Navigation:**
       - Back button or Cancel returns to fueling list
       - onSubmitSuccess navigates to fueling list with updated data

    5. **Imports:**
       - Layout, Heading, Text, Button from Chakra
       - FuelingForm from components/fueling
       - useSession from next-auth/react
       - useRouter from next/router
       - useQuery from @tanstack/react-query
       - Loading, ErrorAlert from components/ui/

    **Edit page specific:**
    - Verify fueling belongs to the vehicle (security check)
    - Pre-populate form with fueling data
    - Page title: "Edit Fueling - {date}"

    **File sizes:**
    - new.tsx: ~60 lines
    - edit.tsx: ~80 lines (has additional data fetching)

  </action>
  <verify>wc -l pages/vehicles/[id]/fuelings/new.tsx pages/vehicles/[id]/fuelings/[fuelingId]/edit.tsx</verify>
  <done>Both create and edit pages exist with proper vehicle context, form components, and navigation flow</done>
</task>

<task type="checkpoint:human-verify">
  <name>Task 4: Verify complete fueling flow</name>
  <what-built>
    Complete fueling records feature with:
    - API routes for list, create, update, delete
    - Fueling list page with infinite scroll and monthly grouping
    - Create fueling page with smart defaults and live calculation
    - Edit fueling page with pre-filled data
    - Delete confirmation modal
  </what-built>
  <how-to-verify>
    1. Start development server: `npm run dev`
    2. Navigate to a vehicle detail page (e.g., /vehicles/1)
    3. Click "Fuelings" or navigate to /vehicles/[id]/fuelings
    4. **Empty state:** Should show "No fuelings yet" with Add Fueling button
    5. Click "Add Fueling" → goes to new page
    6. **Form fields in order:**
       - Enter Total Price (e.g., 200)
       - Enter Liters (e.g., 30) → Price per Liter should update to 6.667
       - Toggle Full Tank (default on)
       - Enter Odometer (should show hint with last value)
       - Date should default to today
    7. Click Save → should navigate back to list with success toast
    8. **List display:** Should show new fueling with date, cost, price-per-liter
    9. Click Edit → goes to edit page with pre-filled values
    10. Change a value and Save → back to list with updated data
    11. Click Delete → modal appears with warning
    12. Confirm Delete → item removed, success toast shown
  </how-to-verify>
  <resume-signal>Type "approved" if all verification steps pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After completion:
1. Check all API files compile without errors
2. Verify page files have correct imports
3. Confirm routes follow REST conventions
4. Test that navigation flows work as specified
</verification>

<success_criteria>

- pages/api/fueling/index.ts: Handles GET (list) and POST (create) with pagination
- pages/api/fueling/last.ts: Returns most recent fueling for smart defaults
- pages/api/fueling/[id].ts: Handles GET, PUT, DELETE for single fueling
- pages/vehicles/[id]/fuelings/index.tsx: List page with FuelingList component
- pages/vehicles/[id]/fuelings/new.tsx: Create page with FuelingForm (mode='create')
- pages/vehicles/[id]/fuelings/[fuelingId]/edit.tsx: Edit page with FuelingForm (mode='edit')
- All pages have proper auth checks and error handling
- Complete user flow verified and working
  </success_criteria>

<output>
After completion, create `.planning/phases/03-fueling-records/03-04-SUMMARY.md`
</output>
