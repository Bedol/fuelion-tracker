---
phase: 03-fueling-records
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - hooks/useFuelings.ts
  - hooks/useCreateFueling.ts
  - hooks/useUpdateFueling.ts
  - hooks/useDeleteFueling.ts
  - hooks/useFuelingDraft.ts
  - hooks/useLastFuelingData.ts
autonomous: true

must_haves:
  truths:
    - 'useFuelings hook returns paginated data with infinite scroll support'
    - 'CRUD mutations (create, update, delete) work with proper success/error handling'
    - 'Draft hook saves form state to localStorage with debounce'
    - 'Last fueling hook fetches most recent fueling for smart defaults'
    - 'All hooks use proper TanStack Query patterns with toast notifications'
  artifacts:
    - path: 'hooks/useFuelings.ts'
      provides: 'Infinite scroll query for fueling list'
      exports: ['useFuelings', 'FUELINGS_PER_PAGE']
      min_lines: 40
    - path: 'hooks/useCreateFueling.ts'
      provides: 'Create mutation with toast notification'
      exports: ['useCreateFueling']
      min_lines: 30
    - path: 'hooks/useUpdateFueling.ts'
      provides: 'Update mutation with toast notification'
      exports: ['useUpdateFueling']
      min_lines: 30
    - path: 'hooks/useDeleteFueling.ts'
      provides: 'Delete mutation with toast notification'
      exports: ['useDeleteFueling']
      min_lines: 30
    - path: 'hooks/useFuelingDraft.ts'
      provides: 'Draft persistence to localStorage'
      exports: ['useFuelingDraft']
      min_lines: 50
    - path: 'hooks/useLastFuelingData.ts'
      provides: 'Fetch last fueling for smart defaults'
      exports: ['useLastFuelingData']
      min_lines: 25
  key_links:
    - from: 'useFuelings'
      to: '/api/fueling?vehicleId=X&skip=Y&take=Z'
      via: 'fetch with pagination params'
      pattern: 'useInfiniteQuery'
    - from: 'useCreateFueling'
      to: 'POST /api/fueling'
      via: 'mutationFn with fetch POST'
      pattern: 'mutation.mutate(values)'
    - from: 'useFuelingDraft'
      to: 'localStorage'
      via: 'localStorage.setItem with debounce'
      pattern: 'localStorage.setItem.*fueling-draft'
---

<objective>
Create all TanStack Query hooks and custom hooks for fueling records functionality.

Purpose: This plan creates the data layer for Phase 3 - hooks that handle fetching, creating, updating, and deleting fuelings, plus utilities for draft persistence and smart defaults. These hooks follow established patterns from the codebase and Phase 2.

Output: Six hook files in hooks/ directory with complete implementations.
</objective>

<execution_context>
@/home/bweber/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/bweber/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/03-fueling-records/03-01-SUMMARY.md
@types/fueling_types.ts

**Prior patterns to follow:**

- Use `toaster.create()` for notifications (from STATE.md - 02-03 decision)
- TanStack Query v5 patterns with useInfiniteQuery for pagination
- Follow useMutation pattern from DeleteVehicleModal.tsx

**Research patterns (from 03-RESEARCH.md):**

**useFuelings hook pattern:**

```typescript
export const FUELINGS_PER_PAGE = 20;
export const useFuelings = (vehicleId: number) => {
	return useInfiniteQuery({
		queryKey: ['fuelings', vehicleId],
		queryFn: async ({ pageParam = 0 }) => {
			const response = await fetch(
				`/api/fueling?vehicleId=${vehicleId}&skip=${pageParam}&take=${FUELINGS_PER_PAGE}`
			);
			if (!response.ok) throw new Error('Failed to fetch fuelings');
			return response.json();
		},
		getNextPageParam: (lastPage, allPages) => {
			if (lastPage.length === FUELINGS_PER_PAGE) {
				return allPages.length * FUELINGS_PER_PAGE;
			}
			return undefined;
		},
		initialPageParam: 0,
	});
};
```

**useFuelingDraft pattern:**

```typescript
const DRAFT_KEY = (vehicleId: number) => `fueling-draft-${vehicleId}`;
// Load, save (debounced), clear draft with beforeunload warning
```

**API endpoints expected:**

- GET /api/fueling?vehicleId=X&skip=Y&take=Z - List fuelings
- GET /api/fueling/last?vehicleId=X - Get last fueling for defaults
- POST /api/fueling - Create fueling
- PUT /api/fueling/[id] - Update fueling
- DELETE /api/fueling/[id] - Delete fueling
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create data fetching hooks (useFuelings, useLastFuelingData)</name>
  <files>hooks/useFuelings.ts, hooks/useLastFuelingData.ts</files>
  <action>
    Create two data fetching hooks following TanStack Query patterns:

    **hooks/useFuelings.ts:**
    - Export `FUELINGS_PER_PAGE = 20` constant
    - Create `useFuelings(vehicleId: number)` hook using `useInfiniteQuery`
    - Query key: `['fuelings', vehicleId]`
    - Fetch URL: `/api/fueling?vehicleId=${vehicleId}&skip=${pageParam}&take=${FUELINGS_PER_PAGE}`
    - Sort order: newest first (API handles this)
    - Error handling: throw Error if response not ok
    - Return all useInfiniteQuery properties (data, fetchNextPage, hasNextPage, isFetchingNextPage, isLoading, isError)

    **hooks/useLastFuelingData.ts:**
    - Create `useLastFuelingData(vehicleId: number)` hook using `useQuery`
    - Query key: `['lastFueling', vehicleId]`
    - Fetch URL: `/api/fueling/last?vehicleId=${vehicleId}`
    - Returns null if 404 (no previous fueling)
    - staleTime: 5 * 60 * 1000 (5 minutes) to avoid excessive refetching

    **Import requirements:**
    - Import from '@tanstack/react-query'
    - Import FuelingData from '../types/fueling_types'

    Follow project hook patterns (camelCase names, explicit return types not required but helpful).

  </action>
  <verify>ls -la hooks/useFuelings.ts hooks/useLastFuelingData.ts</verify>
  <done>Both hooks exist with proper useInfiniteQuery and useQuery implementations, correct query keys, and API endpoint calls</done>
</task>

<task type="auto">
  <name>Task 2: Create mutation hooks (useCreateFueling, useUpdateFueling, useDeleteFueling)</name>
  <files>hooks/useCreateFueling.ts, hooks/useUpdateFueling.ts, hooks/useDeleteFueling.ts</files>
  <action>
    Create three mutation hooks following the pattern from DeleteVehicleModal.tsx:

    **hooks/useCreateFueling.ts:**
    - `useCreateFueling()` returns useMutation
    - mutationFn: POST to `/api/fueling` with fueling data
    - onSuccess: toaster.create({ type: 'success', title: 'Fueling added', description: 'Record saved successfully.' })
    - onError: toaster.create({ type: 'error', title: 'Failed to add fueling', description: error.message })
    - Success invalidates: ['fuelings', vehicleId] and ['lastFueling', vehicleId] queries

    **hooks/useUpdateFueling.ts:**
    - `useUpdateFueling()` returns useMutation
    - mutationFn: PUT to `/api/fueling/${id}` with updated data
    - onSuccess: toaster.create({ type: 'success', title: 'Fueling updated', description: 'Changes saved.' })
    - onError: toaster.create({ type: 'error', title: 'Failed to update', description: error.message })
    - Success invalidates: ['fuelings', vehicleId] query

    **hooks/useDeleteFueling.ts:**
    - `useDeleteFueling()` returns useMutation
    - mutationFn: DELETE to `/api/fueling/${id}`
    - onSuccess: toaster.create({ type: 'success', title: 'Fueling deleted', description: 'Record removed.' })
    - onError: toaster.create({ type: 'error', title: 'Failed to delete', description: error.message })
    - Success invalidates: ['fuelings', vehicleId] and ['lastFueling', vehicleId] queries

    **Important:** All hooks must import `toaster` from '../components/ui/toaster' (follow project pattern).
    All hooks should handle the error case where response.json() fails (use .catch(() => ({}))).

  </action>
  <verify>ls -la hooks/useCreateFueling.ts hooks/useUpdateFueling.ts hooks/useDeleteFueling.ts</verify>
  <done>All three mutation hooks exist with proper mutationFn, success/error toast notifications, and query invalidation</done>
</task>

<task type="auto">
  <name>Task 3: Create draft persistence hook (useFuelingDraft)</name>
  <files>hooks/useFuelingDraft.ts</files>
  <action>
    Create `hooks/useFuelingDraft.ts` for auto-saving form drafts to localStorage:

    **Hook signature:** `useFuelingDraft(vehicleId: number)`

    **Features:**
    1. **Load draft:** Returns saved draft from localStorage or null
       - Key: `fueling-draft-${vehicleId}`
       - Check typeof window !== 'undefined' for SSR safety

    2. **Save draft:** Debounced save function (1 second delay)
       - Use useCallback with debounce
       - Only save if values have actually changed (formik.dirty check will be in component)
       - JSON.stringify the form values

    3. **Clear draft:** Remove from localStorage
       - Call after successful form submission

    4. **Has draft state:** Boolean indicating if draft exists

    5. **beforeunload warning:** useEffect that adds window event listener
       - Warns user if they try to close tab with unsaved draft
       - Pattern: `e.preventDefault(); e.returnValue = '';`

    **Implementation approach:**
    ```typescript
    export const useFuelingDraft = (vehicleId: number) => {
      const [hasDraft, setHasDraft] = useState(false);

      const DRAFT_KEY = `fueling-draft-${vehicleId}`;

      const loadDraft = useCallback(() => {
        if (typeof window === 'undefined') return null;
        const saved = localStorage.getItem(DRAFT_KEY);
        return saved ? JSON.parse(saved) : null;
      }, [DRAFT_KEY]);

      const saveDraft = useCallback(
        debounce((values: Record<string, unknown>) => {
          if (typeof window === 'undefined') return;
          localStorage.setItem(DRAFT_KEY, JSON.stringify(values));
          setHasDraft(true);
        }, 1000),
        [DRAFT_KEY]
      );

      const clearDraft = useCallback(() => {
        if (typeof window === 'undefined') return;
        localStorage.removeItem(DRAFT_KEY);
        setHasDraft(false);
      }, [DRAFT_KEY]);

      // beforeunload effect here

      return { loadDraft, saveDraft, clearDraft, hasDraft };
    };
    ```

    **Import debounce from lodash or use simple implementation:**
    The project doesn't have lodash, so implement simple debounce:
    ```typescript
    const debounce = (fn: Function, ms: number) => {
      let timeoutId: ReturnType<typeof setTimeout>;
      return (...args: unknown[]) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => fn(...args), ms);
      };
    };
    ```

    Return type should be explicit for TypeScript.

  </action>
  <verify>cat hooks/useFuelingDraft.ts | grep -E "(loadDraft|saveDraft|clearDraft|hasDraft|beforeunload)" | head -10</verify>
  <done>useFuelingDraft hook exists with loadDraft, saveDraft (debounced), clearDraft, hasDraft, and beforeunload warning functionality</done>
</task>

</tasks>

<verification>
After completion:
1. Verify all 6 hook files exist in hooks/ directory
2. Check imports are correct (from '@tanstack/react-query', '../types/fueling_types', '../components/ui/toaster')
3. Ensure no TypeScript errors (check with `npx tsc --noEmit` if needed)
4. Verify query keys follow pattern: ['fuelings', vehicleId], ['lastFueling', vehicleId]
</verification>

<success_criteria>

- hooks/useFuelings.ts: Exports FUELINGS_PER_PAGE and useFuelings with useInfiniteQuery
- hooks/useCreateFueling.ts: Exports useCreateFueling with POST mutation and toast notifications
- hooks/useUpdateFueling.ts: Exports useUpdateFueling with PUT mutation and toast notifications
- hooks/useDeleteFueling.ts: Exports useDeleteFueling with DELETE mutation and toast notifications
- hooks/useFuelingDraft.ts: Exports useFuelingDraft with localStorage persistence and beforeunload warning
- hooks/useLastFuelingData.ts: Exports useLastFuelingData with useQuery for last fueling
- All hooks follow project patterns and use proper TypeScript types from fueling_types.ts
  </success_criteria>

<output>
After completion, create `.planning/phases/03-fueling-records/03-02-SUMMARY.md`
</output>
